---
layout: post
title: "B-Tree"
subtitle: "index"
category: "database"
date: 2024-04-05
background: '/img/posts/btree.png'
---

## B Tree 구조

- 자식 2개만을 갖는 이진 트리(Binary Tree)를 확장하여 N개의 자식을 가질 수 있음
- 좌우 자식 간의 균형이 맞지 않을 경우 비효율적이라 항상 균형을 맞춘다는 의미로 균형 트리라고도 부름

<br>

![](/img/posts/btree.png)

<br>

## 페이지

`디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위`

일반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다.

ex. 쿼리를 통해 1개의 레코드를 읽는다 -> 하나의 블록을 읽어야함.

<br> 

> 페이지에 저장되는 개별 데이터의 크기를 최대한 작게하여, 
> 
> 1개의 페이지에 많은 데이터를 저장할 수 있도록 하는 것이 중요

<br>
<br>

## B-Tree 인덱스의 구조

**테이블**

```SQL
CREATE TABLE employee (
    emp_no INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(64),
    PRIMARY KEY(emp_no),
    INDEX idx_name (name)
) ENGINE=InnoDB;
```

![](/img/posts/btree2.png)

<br>

모든 페이지는 키 값을 기준으로 정렬되어 있으며 `idx_name` 인덱스의 경우, `name을 기준`으로 정렬되어 있고, 데이터를 따라 리프노드에 도달하면 인덱스 키에 해당하는 레코드의 PK 값이 저장되어 있다.

인덱스는 테이블과 독립적인 저장 공간이므로 인덱스를 통해 데이터를 조회하려면 먼저 PK를 찾아야 한다. PK로 레코드를 조회할 때는 (인덱스 영역에서 테이블 영역으로 넘어가는 경우) PK가 어느 페이지에 저장되어 있는지 알 수 없으므로 랜덤 I/O가 발생하게 된다. 이후에는 PK를 따라 리프노드에서 실제 레코드를 읽어온다. 참고로 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데, 랜덤 I/O는 임의의 장소에서 데이터를 가져오지만 순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다.

<br>
<br>

### 인덱스가 필요한 이유

인덱스를 통해 조회하는 것은 아래 2개의 작업이 수행된다.

1. 인덱스를 통해 PK를 찾는다.
2. PK를 통해 레코드를 찾는다.

<br>

옵티마이저는 인덱스를 통해 레코드 한 건을 읽는 것이 테이블을 통해 직접 읽는 것 보다 `4~5배` 정도 비용이 더 많이 들 것으로 예측한다.

따라서, 읽어야 할 레코드의 건수가 전체 테이블 레코드의 `20~25%`를 넘어서면 인덱스를 사용하지 않는 것이 효율적이다. (옵티마이저의 역할)

<br>
<br>

## 인덱스 사용에 영향을 주는 요소

<br>

### PK의 크기



<br>
<br>
<br>

<details open="open">
<summary>참고 링크</summary>
<div markdown="1">
<https://mangkyu.tistory.com/286>
<div>
